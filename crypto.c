#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>

typedef struct {
    unsigned char pR, pG, pB;
} pixel;

/*
Generate random numbers using the xorshift32 generator(https://en.wikipedia.org/wiki/Xorshift) and store them in a given array.
Parameters:
- width and height of the image
- seed is used to initialize the xorshift32 generator, also it is the first number from secret_key.txt
- elements_array contains the generated values, it will have 2 * image_width * image_height generated numbers,the elements are sent back by using the elements_array variable
*/
void xorshift32(unsigned int image_width, unsigned int image_height, unsigned int seed, unsigned int **elements_array)
{
    *elements_array = (unsigned int *)malloc(sizeof(unsigned int) * 2 * image_width * image_height);
    for (unsigned int aux = seed, i = 0; i < 2 * image_width * image_height; i++)
    {
        aux ^= aux << 13;
        aux ^= aux >> 17;
        aux ^= aux << 5;
        (*elements_array)[i] = aux;
    }
}

/*
Generate random permutation using a sequence of random numbers generated by xorshift32 algorithm.
Info:
- it is a more modern variant of the Fisher Yantes Shuffle
- https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
*/
void durstenfeld_permutation(unsigned int **permutation, unsigned int image_width, unsigned int image_height,
                             unsigned int *xorshift32_generated_array)
{
    *permutation = (unsigned int *)malloc(sizeof(unsigned int) * image_width * image_height);
    for (unsigned int i = 0; i < image_width * image_height; i++)
    {
        (*permutation)[i] = i;
    }

    for (unsigned int i = image_width * image_height - 1; i > 0; i--)//TO DO: check if it should be >= 0
    {
        unsigned int poz = xorshift32_generated_array[i] % (i + 1);
        unsigned int aux = (*permutation)[poz];
        (*permutation)[poz] = (*permutation)[i];
        (*permutation)[i] = aux;
    }
}

/*
Purpose: generate the inverse of the durstenfeld permutation
Info:
- initial_permutation is the one generated using the durstenfeld algorithm
*/
void inverse_permutation(unsigned int **final_permutation, unsigned int *initial_permutation, unsigned int image_width, unsigned int image_height)
{
    *final_permutation = (unsigned int *)malloc(sizeof(unsigned int) * image_width * image_height);
    for (unsigned int i = 0; i < image_width * image_height; i++)
        (*final_permutation)[initial_permutation[i]] = i;
}

/*
Purpose: read and store the image pixels in an array of width*height size instead of a matrix with same size
Info:
- this works only for .bmp images with header size of 54 bytes.
*/
void image_linearization(pixel **image_pixels, unsigned int image_width, unsigned int image_height, FILE *image_file_handle)
{
    unsigned char pixel_rgb[3];
    *image_pixels = (pixel *)malloc(sizeof(pixel) * image_width * image_height);
    fseek(image_file_handle, 54, SEEK_SET);
    for (unsigned int i = 0; i < image_width * image_height; i++)
    {
        fread(pixel_rgb, 3, 1, image_file_handle);
        (*image_pixels)[i].pR = pixel_rgb[0];
        (*image_pixels)[i].pG = pixel_rgb[1];
        (*image_pixels)[i].pB = pixel_rgb[2];
    }
}

/*
Purpose: permutes the pixels stored in the array initialized at image_linearization step
Info:
- the image must be linearized otherwise it will give wrong results
*/
void permute_image_pixels(pixel **linearized_and_permuted_form, pixel **linearized_form, unsigned int *permutations,
                          unsigned int image_width, unsigned int image_height)
{
    *linearized_and_permuted_form = (pixel *)malloc(sizeof(pixel) * image_width * image_height);
    for (unsigned int i = 0; i < image_width * image_height; i++)
        (*linearized_and_permuted_form)[*(permutations + i)] = (*linearized_form)[i];
}

/*
Purpose: For each pixel a substitution is made in order to encrypt the image
Info:
- the Secret_Values is the second value from secret_key.txt file
- this will create the encrypted image pixels which will be used to create a new image
- if any function gave wrong results this final step might create an image which can not be decrypted and might not be even safe to use because it might not have a strong encryption
*/
void final_image_encryption(pixel **final_image, pixel **linearized_form, unsigned int *xorshift32_array, unsigned int image_width, unsigned int image_height, unsigned int Secret_Value)
{
    *final_image = (pixel *)malloc(sizeof(pixel) * image_width * image_height);

    int octet_2 = (Secret_Value >> 16) & 0xff;
    int octet_1 = (Secret_Value >> 8) & 0xff;
    int octet_0 = Secret_Value & 0xff;

    unsigned int i = 0, j = image_width * image_height;
    (*final_image)[i].pR = octet_0 ^ (*linearized_form)[i].pR ^ (*(xorshift32_array + j));
    (*final_image)[i].pG = octet_1 ^ (*linearized_form)[i].pG ^ (*(xorshift32_array + j));
    (*final_image)[i].pB = octet_2 ^ (*linearized_form)[i].pB ^ (*(xorshift32_array + j));

    for (i = 1; i < image_width * image_height; i++)
    {
        j++;
        (*final_image)[i].pR = (*final_image)[i - 1].pR ^ (*linearized_form)[i].pR ^ (*(xorshift32_array + j));
        (*final_image)[i].pG = (*final_image)[i - 1].pG ^ (*linearized_form)[i].pG ^ (*(xorshift32_array + j));
        (*final_image)[i].pB = (*final_image)[i - 1].pB ^ (*linearized_form)[i].pB ^ (*(xorshift32_array + j));
    }
}

/*
Purpose: use the generated data to inverse the substitudion made at encryption
*/
void aplicate_xor(pixel **xored_image, pixel **linearized_from_image_pixels, unsigned int *sir_xorshift32_decr, unsigned int image_width,
                  unsigned image_height, unsigned int Secret_Value)
{
    *xored_image = (pixel *)malloc(sizeof(pixel) * image_width * image_height);

    int b = (Secret_Value >> 16) & 0xff; // third octet  16-23
    int g = (Secret_Value >> 8) & 0xff;  // second octet 8-15
    int r = Secret_Value & 0xff;         // first octet  0-7

    unsigned int i = 0, j = image_width * image_height;
    (*xored_image)[i].pR = r ^ (*linearized_from_image_pixels)[i].pR ^ (*(sir_xorshift32_decr + j));
    (*xored_image)[i].pG = g ^ (*linearized_from_image_pixels)[i].pG ^ (*(sir_xorshift32_decr + j));
    (*xored_image)[i].pB = b ^ (*linearized_from_image_pixels)[i].pB ^ (*(sir_xorshift32_decr + j));

    for (i = 1; i < image_width * image_height; i++)
    {
        j++;
        (*xored_image)[i].pR = (*linearized_from_image_pixels)[i - 1].pR ^ (*linearized_from_image_pixels)[i].pR ^ (*(sir_xorshift32_decr + j));
        (*xored_image)[i].pG = (*linearized_from_image_pixels)[i - 1].pG ^ (*linearized_from_image_pixels)[i].pG ^ (*(sir_xorshift32_decr + j));
        (*xored_image)[i].pB = (*linearized_from_image_pixels)[i - 1].pB ^ (*linearized_from_image_pixels)[i].pB ^ (*(sir_xorshift32_decr + j));
    }
}

/*
Purpose: here are all the used steps in order to encrypt the image
Info:
- return value is used for error handling(1 = success, -1 = failure)
*/
int encrypt(char *input_image_name, char *output_image_name, char *secret_key_file_name)
{
    FILE *secret_key_file_handle, *input_image_file_handle, *output_image_file_handle;
    secret_key_file_handle = fopen(secret_key_file_name, "r");
    if (secret_key_file_handle == NULL)
    {
        printf("Could not open/find the file with the secret key!\n");
        return -1;
    }
    unsigned int generator_seed = 0, starting_value = 0;
    fscanf(secret_key_file_handle, "%d", &generator_seed);
    fscanf(secret_key_file_handle, "%d", &starting_value);
    fclose(secret_key_file_handle);

    input_image_file_handle = fopen(input_image_name, "rb+");
    if (input_image_file_handle == NULL)
    {
        printf("The image which you wanted to encrypt could not be found!\n");
        return -1;
    }

    unsigned int image_size = 0, image_width = 0, image_height = 0;
    fseek(input_image_file_handle, 2, SEEK_SET);
    fread(&image_size, sizeof(unsigned int), 1, input_image_file_handle);

    fseek(input_image_file_handle, 18, SEEK_SET);
    fread(&image_width, sizeof(unsigned int), 1, input_image_file_handle);
    fread(&image_height, sizeof(unsigned int), 1, input_image_file_handle);

    output_image_file_handle = fopen(output_image_name, "wb+");
    if (output_image_file_handle == NULL)
    {
        printf("Output file could not be oppened.\n");
        return -1;
    }

    unsigned int c = 0, j = 0;
    fseek(input_image_file_handle, 0, SEEK_SET);
    while (fread(&c, 1, 1, input_image_file_handle) == 1 && j < 54)
    {
        j++;
        fwrite(&c, 1, 1, output_image_file_handle);
    }

    unsigned int *xorshift32_generated_values_array;
    xorshift32(image_width, image_height, generator_seed, &xorshift32_generated_values_array);

    unsigned int *permutation;
    durstenfeld_permutation(&permutation, image_width, image_height, xorshift32_generated_values_array);

    pixel *liearized_form;
    image_linearization(&liearized_form, image_width, image_height, input_image_file_handle);

    pixel *linearized_and_permuted_form;
    permute_image_pixels(&linearized_and_permuted_form, &liearized_form, permutation, image_width, image_height);
    free(permutation);
    free(liearized_form);

    pixel *ciphered_image;
    final_image_encryption(&ciphered_image, &linearized_and_permuted_form, xorshift32_generated_values_array, image_width, image_height, starting_value);
    free(xorshift32_generated_values_array);
    free(linearized_and_permuted_form);

    int padding = 0;
    if (image_width % 4 != 0)
    {
        padding = 4 - (3 * image_width) % 4;
    }

    for (unsigned int i = 0; i < image_height; i++)
    {
        for (unsigned int j = 0; j < image_width; j++)
        {
            fwrite(ciphered_image + (image_height * i + j), 3, 1, output_image_file_handle);
        }
        fseek(output_image_file_handle, padding, SEEK_CUR);
    }
    free(ciphered_image);

    fclose(input_image_file_handle);
    fclose(output_image_file_handle);

#ifdef CRYPTO_TEST
    printf("Encryption passed\r\n");
#endif

    return 1;
}

/*
Decrypt an image given:
- name of encrypted image
- name for the decrypted image
- name for the file containing secrets for decryption
*/
int decrypt(char *encrypted_image_name, char *decrypted_image_name, char *secret_key_file_name)
{
    FILE *input_image_file_handle, *output_image_file_handle, *secret_key_file_handle;
    input_image_file_handle = fopen(encrypted_image_name, "rb+");
    output_image_file_handle = fopen(decrypted_image_name, "wb+");
    secret_key_file_handle = fopen(secret_key_file_name, "r");

    if (input_image_file_handle == NULL)
    {
        printf("The given image was not found!\n");
        return -1;
    }

    if (secret_key_file_handle == NULL)
    {
        printf("Error at file open!\nCheck if you correctly spelled its name, or if it is present in the same directory as the executable file.");
        return -1;
    }

    unsigned int generator_seed = 0, starting_value = 0;
    fscanf(secret_key_file_handle, "%d", &generator_seed);
    fscanf(secret_key_file_handle, "%d", &starting_value);
    fclose(secret_key_file_handle);

    unsigned int image_size = 0, image_width = 0, image_height = 0;
    fseek(input_image_file_handle, 2, SEEK_SET);
    fread(&image_size, sizeof(unsigned int), 1, input_image_file_handle);
    fseek(input_image_file_handle, 18, SEEK_SET);
    fread(&image_width, sizeof(unsigned int), 1, input_image_file_handle);
    fread(&image_height, sizeof(unsigned int), 1, input_image_file_handle);

    // Copy the encrypted image header into the new one
    int j = 0;
    unsigned c;
    fseek(input_image_file_handle, 0, SEEK_SET);
    while (fread(&c, 1, 1, input_image_file_handle) == 1 && j < 54)
    {
        j++;
        fwrite(&c, 1, 1, output_image_file_handle);
    }

    unsigned int *xorshift32_generated_values_array;
    xorshift32(image_width, image_height, generator_seed, &xorshift32_generated_values_array);

    unsigned int *durstenfeld_permutation_elements;
    durstenfeld_permutation(&durstenfeld_permutation_elements, image_width, image_height, xorshift32_generated_values_array);

    unsigned int *final_permutation;
    inverse_permutation(&final_permutation, durstenfeld_permutation_elements, image_width, image_height);
    free(durstenfeld_permutation_elements);

    pixel *linearized_encrypted_image_pixels;
    image_linearization(&linearized_encrypted_image_pixels, image_width, image_height, input_image_file_handle);

    pixel *decoded_image;
    aplicate_xor(&decoded_image, &linearized_encrypted_image_pixels, xorshift32_generated_values_array, image_width, image_height, starting_value);
    free(xorshift32_generated_values_array);
    free(linearized_encrypted_image_pixels);

    pixel *permuted_decoded_image;
    permute_image_pixels(&permuted_decoded_image, &decoded_image, final_permutation, image_width, image_height);
    free(final_permutation);
    free(decoded_image);

    int padding = 0;
    if (image_width % 4 != 0)
    {
        padding = 4 - (3 * image_width) % 4;
    }

    for (unsigned int i = 0; i < image_height; i++)
    {
        for (unsigned int j = 0; j < image_width; j++)
        {
            fwrite(permuted_decoded_image + (image_width * i + j), 3, 1, output_image_file_handle);
        }
        fseek(output_image_file_handle, padding, SEEK_CUR);
    }
    free(permuted_decoded_image);

    fclose(input_image_file_handle);
    fclose(output_image_file_handle);
    return 1;
}

int chi_squared_test(char *image_name)
{
    unsigned int image_size, image_width, image_height, f_bar, i = 0, j = 0, *pixel1, *pixel2, *pixel3;
    double nr1 = 0, nr2 = 0, nr3 = 0;

    FILE *file_handle;
    file_handle = fopen(image_name, "rb+");

    if (file_handle == NULL)
    {
        printf("Image file count not be oppened for the chi_squared test.\n");
        return -1;
    }

    fseek(file_handle, 2, SEEK_SET);
    fread(&image_size, sizeof(unsigned int), 1, file_handle);
    fseek(file_handle, 18, SEEK_SET);
    fread(&image_width, sizeof(unsigned int), 1, file_handle);
    fread(&image_height, sizeof(unsigned int), 1, file_handle);

    pixel1 = (unsigned int *)malloc(sizeof(unsigned int) * 256);
    pixel2 = (unsigned int *)malloc(sizeof(unsigned int) * 256);
    pixel3 = (unsigned int *)malloc(sizeof(unsigned int) * 256);

    for (i = 0; i < 256; i++)
    {
        *(pixel1 + i) = 0;
        *(pixel2 + i) = 0;
        *(pixel3 + i) = 0;
    }

    fseek(file_handle, 0, SEEK_SET);
    pixel *imagine_liniarizata;
    image_linearization(&imagine_liniarizata, image_width, image_height, file_handle);
    f_bar = (image_height * image_width) / 256;

    for (j = 0; j < 256; j++)
    {
        for (i = 0; i < image_height * image_width; i++)
        {
            if (((*(imagine_liniarizata + i)).pR) == j)
                (*(pixel1 + j)) = (*(pixel1 + j)) + 1;
            if (((*(imagine_liniarizata + i)).pG) == j)
                (*(pixel2 + j)) = (*(pixel2 + j)) + 1;
            if (((*(imagine_liniarizata + i)).pB) == j)
                (*(pixel3 + j)) = (*(pixel3 + j)) + 1;
        }
    }

    for (i = 0; i < 256; i++)
    {
        nr1 += (double)(((*(pixel1 + i)) - f_bar) * ((*(pixel1 + i)) - f_bar)) / f_bar;
        nr2 += (double)(((*(pixel2 + i)) - f_bar) * ((*(pixel2 + i)) - f_bar)) / f_bar;
        nr3 += (double)(((*(pixel3 + i)) - f_bar) * ((*(pixel3 + i)) - f_bar)) / f_bar;
    }

    free(pixel3);
    free(pixel2);
    free(pixel1);

    printf("Chi_squared results:\n%.2f, %.2f, %.2f .\n", nr3, nr2, nr1);

    fclose(file_handle);
    return 1;
}

#ifndef CRYPTO_TEST
int main(void)
{
    int user_choice = 0;
    bool EXIT_STATUS_FLAG = false;

    while (!EXIT_STATUS_FLAG)
    {
        printf("Operation id(1 encryption, 2 decryption, 3 chi_squared test, 4 exit):");

        char input_image_name[101];
        char encrypted_image_name[101];
        char secret_key_file_name[101];
        char decrypted_image_name[101] = "decodedpeppers.bmp";

        int operation_result = scanf("%d", &user_choice);
        if (operation_result == EOF)
        {
            printf("The program needs a valid option!\n");
            continue;
        }
        if (operation_result == 0)
        {
            while (fgetc(stdin) != '\n')
                ;
            printf("The program needs a valid option!\n");
            continue;
        }
        getchar();

        switch (user_choice)
        {
        case 1:
            printf("Name of the image that you want to encrypt(perhaps peppers.bmp): ");
            fgets(input_image_name, 101, stdin);
            input_image_name[strlen(input_image_name) - 1] = '\0';

            printf("\nName of the new encrypted image(perhaps encodedpeppers.bmp): ");
            fgets(encrypted_image_name, 101, stdin);
            encrypted_image_name[strlen(encrypted_image_name) - 1] = '\0';

            printf("\nName of the file which contains the secret key(perhaps secret_key.txt): ");
            fgets(secret_key_file_name, 101, stdin);
            secret_key_file_name[strlen(secret_key_file_name) - 1] = '\0';

            int encryption_result = encrypt(input_image_name, encrypted_image_name, secret_key_file_name);
            if (encryption_result == -1)
                return -1;
            if (encryption_result == 1)
                printf("The image was succesfully encrypted.\n");

            break;
        case 2:
            printf("\nName of the new encrypted image(perhaps encodedpeppers.bmp): ");
            fgets(encrypted_image_name, 101, stdin);
            encrypted_image_name[strlen(encrypted_image_name) - 1] = '\0';

            printf("\nName of the file which contains the secret key(perhaps secret_key.txt): ");
            fgets(secret_key_file_name, 101, stdin);
            secret_key_file_name[strlen(secret_key_file_name) - 1] = '\0';

            printf("The name of the decrypted image is 'decodedpeppers.bmp'\n");
            int decryption_result = decrypt(encrypted_image_name, decrypted_image_name, secret_key_file_name);
            if (decryption_result == -1)
                return -1;
            if (decryption_result == 1)
                printf("The image was succesfully decrypted.\n");

            break;
        case 3:
            printf("Name of the image that you want to encrypt(perhaps peppers.bmp): ");
            fgets(input_image_name, 101, stdin);
            input_image_name[strlen(input_image_name) - 1] = '\0';

            printf("\nName of the new encrypted image(perhaps encodedpeppers.bmp): ");
            fgets(encrypted_image_name, 101, stdin);
            encrypted_image_name[strlen(encrypted_image_name) - 1] = '\0';

            int input_image_result = chi_squared_test(input_image_name);
            int encrypted_image_result = chi_squared_test(encrypted_image_name);
            if (input_image_result == -1 || encrypted_image_result == -1)
                continue;
            if (input_image_result == 1 && encrypted_image_result == 1)
                printf("Chi-squared tests were succesfully done!\n");

            break;
        case 4:
            EXIT_STATUS_FLAG = true;
            printf("Program closed succesfully!\nBye!\n");
            break;
        default:
            printf("Please choose a valid option!\n");
        }
    }

    return 0;
}
#endif
